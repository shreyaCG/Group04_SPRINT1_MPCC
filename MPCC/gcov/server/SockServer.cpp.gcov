        -:    0:Source:SockServer.cpp
        -:    1:#include "SockServer.h"
        -:    2:#include "details.h"
        -:    3:
        -:    4:/*Creation of Server Socket using socket() system call and
        -:    5:error handling, if server socket is not created.
        -:    6:setsockopt() is used to connect multiple sockets of client.
        -:    7:Taking IP Address and Port Number through command line arguments.*/
    #####:    8:void Server::create_socket()
        -:    9:{
    #####:   10:	int option = true;
    #####:   11:	server_socketfd = socket(AF_INET, SOCK_STREAM, 0);
    #####:   12:	if(server_socketfd < 0)
        -:   13:	{
    #####:   14:		log("Fatal log:socket() error");
    #####:   15:		exit(EXIT_FAILURE);
        -:   16:	}
    #####:   17:	if(setsockopt(server_socketfd, SOL_SOCKET, SO_REUSEADDR, (char *)&option, sizeof(option))<0)
        -:   18:	{
    #####:   19:		log("Fatal log: etsockopt() error");
    #####:   20:		exit(EXIT_FAILURE);
        -:   21:	}	
    #####:   22:	log("Info log: [+] Server Socket Created");
        -:   23:
    #####:   24:	memset(&server_addr, 0, sizeof(server_addr));
    #####:   25:	server_addr.sin_family = AF_INET;
    #####:   26:	server_addr.sin_port = htons(portno);
    #####:   27:	server_addr.sin_addr.s_addr = inet_addr((const char*)ipaddr.c_str());
    #####:   28:}
        -:   29:
        -:   30:/*Bind the server to a port using bind() and error handling if server 
        -:   31:is not binded to the port.
        -:   32:Server is waiting for the client connection
        -:   33:and error handling if server is not waiting for the clients.*/
    #####:   34:void Server::bind_listen()
        -:   35:{
    #####:   36:	int Is_bind=bind(server_socketfd,(struct  sockaddr*)&server_addr,sizeof(server_addr));
    #####:   37:	if(Is_bind<0)
        -:   38:	{
    #####:   39:		log("Fatal log: bind() error");
    #####:   40:		exit(EXIT_FAILURE);
        -:   41:	}
    #####:   42:	log("Info log: [+] Server bind to the port");
    #####:   43:	if(listen(server_socketfd, 5)<0)
        -:   44:	{
    #####:   45:		log("Fatal log: listen() error");
    #####:   46:		exit(EXIT_FAILURE);
        -:   47:	}
    #####:   48:	log("Info log: [+] Server listening to the clients");
    #####:   49:}
        -:   50:/*Server accepts the client which is trying to connect using accept() system call
        -:   51: and error handling is done if the client connections are not accepted*/
    #####:   52:int Server::acceptclient(int sfd)
        -:   53:{
    #####:   54:	len = sizeof(client_addr);
    #####:   55:	Client_Socketfd = accept(sfd, (struct sockaddr *)&client_addr, &len);
    #####:   56:	if(Client_Socketfd<0)
        -:   57:	{
    #####:   58:		log("Fatal log: accept() failed");
    #####:   59:		exit(EXIT_FAILURE);
        -:   60:	}
    #####:   61:	log("Info log: [+] Server accepts the client");
    #####:   62:	return Client_Socketfd;
        -:   63:}
        -:   64://close the server socket
    #####:   65:void Server::Server_Close(int socketfd)
        -:   66:{
    #####:   67:	close(socketfd);
    #####:   68:}
        -:   69:/*fd sets are created and cleared
        -:   70: the server socketfd is stored into the fdset
        -:   71: max_socket is set to the server socketfd*/
    #####:   72:void Server::Create_fdset()
        -:   73:{
        -:   74:	//Copy of the fd_set
    #####:   75:	readfds = master;
        -:   76:	//clear the sock set fds
    #####:   77:	FD_ZERO(&readfds);
        -:   78:	//Add the serverfd to the fd_set
    #####:   79:	FD_SET(serverfd,&readfds);
    #####:   80:	max_socket = serverfd;
    #####:   81:}
        -:   82:
        -:   83:/*check if new client is connected and add the client sockets to the fd_set
        -:   84: * and get the highest fd's number which is required for select() function */
    #####:   85:void Server::Add_ClientSocketfd()
        -:   86:{
    #####:   87:	for(int i=0;i<max_clients;i++)
        -:   88:	{
    #####:   89:		SocketFD= client_sockets[i];
        -:   90:		///if valid socket desc... then add to readfds lists
    #####:   91:		if(SocketFD > 0)
    #####:   92:			FD_SET(SocketFD,&readfds);
        -:   93:		//highest fds number, need it for the select fucntion
    #####:   94:		if(SocketFD > max_socket)
    #####:   95:			max_socket = SocketFD;
        -:   96:	}
    #####:   97:}
        -:   98:/*checking if the serverfd is present in the set and
        -:   99: user registration is done  followed by login with the help of switch case
        -:  100: the socket fds of all the active clients are stored in vector*/
    #####:  101:void Server::registeruser_login()
        -:  102:{
    #####:  103:	details *d1 = new details;
    #####:  104:	char user_data[MAX_BUF] = {'\0',}; 
    #####:  105:	int flag=0;
        -:  106:	char buf[MAX_BUF];
    #####:  107:	if(FD_ISSET(serverfd, &readfds))
        -:  108:	{		
    #####:  109:		int Client_Socket = acceptclient(serverfd);	
    #####:  110:		int recvoption=recv(Client_Socket,buf,MAX_BUF,0);
        -:  111:		//check whether client wants to login or register
    #####:  112:		switch(atoi(buf))
        -:  113:		{
        -:  114:			//registeration
    #####:  115:			case 1:
    #####:  116:				if(send(Client_Socket,"register",9,0)<0)
        -:  117:				{
    #####:  118:					log("Fatal log: send() error");
    #####:  119:					exit(EXIT_FAILURE);
        -:  120:				}
        -:  121:				//Receieved UserID and Password
    #####:  122:				if(recv(Client_Socket,&user_data,sizeof(user_data),0)<0)
        -:  123:				{
    #####:  124:					log("Fatal log: recv() error");
    #####:  125:					exit(EXIT_FAILURE);
        -:  126:				}
        -:  127:				//Stores registered users in a file
    #####:  128:				d1->database(user_data);
    #####:  129:				if(send(Client_Socket,"success",8,0)<0)
        -:  130:				{
    #####:  131:					log("Fatal log: send() error");
    #####:  132:					exit(EXIT_FAILURE);
        -:  133:				}
    #####:  134:				break;
        -:  135:			//login
    #####:  136:			case 2:
    #####:  137:				if(send(Client_Socket,"login",8,0)<0)
        -:  138:				{
    #####:  139:					log("Fatal log: send() error");
    #####:  140:					exit(EXIT_FAILURE);
        -:  141:				}
    #####:  142:				memset(user_data,0,sizeof(user_data));
        -:  143:				//Receives the login credentials
    #####:  144:				if(recv(Client_Socket,&user_data,sizeof(user_data),0)<0)
        -:  145:				{
    #####:  146:					log("Fatal log: recv() error");
    #####:  147:					exit(EXIT_FAILURE);
        -:  148:				}
        -:  149:				//Verify if the login credentials matches the registered credentials			
    #####:  150:				fstream fs;
    #####:  151:				string line;
    #####:  152:				fs.open("data/registered.txt");
    #####:  153:				if(fs.is_open())
        -:  154:				{
    #####:  155:					while(!fs.eof())
        -:  156:					{
    #####:  157:						getline(fs,line);
        -:  158:						
    #####:  159:						if((strcmp(user_data,line.c_str())==0))
        -:  160:						{
    #####:  161:							flag=1;
    #####:  162:							break;
        -:  163:						}
        -:  164:					}
    #####:  165:					if(flag==1)
        -:  166:					{
        -:  167:						//Tokenize the login credentials
    #####:  168:						string middle;
    #####:  169:						vector<string> vstring;
    #####:  170:        					stringstream check(user_data);
    #####:  171:        					while(getline(check,middle,'|'))
        -:  172:        					{
    #####:  173:                					vstring.push_back(middle);
        -:  174:        					}
    #####:  175:						d1->setUID((char*)vstring[0].c_str());
    #####:  176:						d1->setPassword((char*)vstring[1].c_str());
    #####:  177:						if(send(Client_Socket,"success",8,0)<0)
        -:  178:						{
    #####:  179:							log("Fatal log: recv() error");
    #####:  180:							exit(EXIT_FAILURE);
        -:  181:						}
        -:  182:
        -:  183:
        -:  184:					}
        -:  185:					else
        -:  186:					{
    #####:  187:						if(send(Client_Socket,"failure",8,0)<0)
        -:  188:						{
    #####:  189:							log("Fatal log: recv() error");
    #####:  190:							exit(EXIT_FAILURE);
        -:  191:						}
        -:  192:
        -:  193:					}
        -:  194:				}
    #####:  195:				fs.close();
        -:  196:				
    #####:  197:				break;
        -:  198:		}
        -:  199:		//add the active client socketfd's in a vector
    #####:  200:		for(int i=0;i<max_clients;i++)
        -:  201:		{
    #####:  202:			if(client_sockets[i] == 0)
        -:  203:			{
    #####:  204:				client_sockets[i] = Client_Socket;
    #####:  205:				log("Info log: [+] Adding the client sockfds to the list");
    #####:  206:				strcpy(uids[i],d1->getUID());
    #####:  207:				v_clientsock.push_back(Client_Socket);
    #####:  208:				break;
        -:  209:			}
        -:  210:		}
        -:  211:	}//end if fd_ISSET
    #####:  212:}
        -:  213:/*The IPAddress and port number of the disconnected clients are displayed
        -:  214: *  and their socket fd's are erased from the vector*/
    #####:  215:void Server::handle_disconnect()
        -:  216:{
    #####:  217:	log("Info log: [+] Client disconnected ");
    #####:  218:	log("Info log: [+] Closing Socket ");
    #####:  219:	close(SocketFD);
    #####:  220:	client_sockets[i] = 0;
    #####:  221:	if(v_clientsock.size()==1)
        -:  222:	{
    #####:  223:		v_clientsock.erase(v_clientsock.begin());
        -:  224:	}
        -:  225:	else
        -:  226:	{
    #####:  227:		v_clientsock.erase(v_clientsock.begin()+i);	
        -:  228:	}
        -:  229:	
    #####:  230:}
        -:  231:/*iterate through the vector which has active client fds and
        -:  232: broadcast the message sent by one client to all other clients connected to the server
        -:  233: along witheir respective user ID*/
    #####:  234:void Server::broadcast_msg()
        -:  235:{
    #####:  236:	string UID;
    #####:  237:	memset(&UID,0,MAX_BUF);
        -:  238:	//to get the user ID of the client which is sending the message	
    #####:  239:	for(int i=0;(i<v_clientsock.size())&&(client_sockets[i] !=0 );i++)
        -:  240:	{
    #####:  241:		int socket=client_sockets[i];
    #####:  242:		if(socket==SocketFD && socket!=serverfd && socket!=0)
        -:  243:		{
    #####:  244:			UID=uids[i];
    #####:  245:			break;
        -:  246:		}
        -:  247:	}
        -:  248:	//broadcast the message to all the active clients
    #####:  249:	for(int i=0;(i<v_clientsock.size())&&(client_sockets[i] !=0 );i++)
        -:  250:	{
    #####:  251:		int socket = client_sockets[i];
        -:  252:		
    #####:  253:		if(socket != SocketFD && socket != serverfd && socket !=0)
        -:  254:		{
    #####:  255:			char tbuff[MAX_BUF] = {'\0',};
    #####:  256:			strcpy(tbuff, "Message sent by ");
    #####:  257:			strcat(tbuff,UID.c_str());
    #####:  258:			strcat(tbuff,": ");
    #####:  259:			strcat(tbuff,buff);
    #####:  260:			strcat(tbuff,"\r\n");							
    #####:  261:      			write(socket, tbuff, strlen(tbuff));
        -:  262:		}
        -:  263:	}
    #####:  264:}	
        -:  265:/*select() allows the server to monitor multiple client connected
        -:  266: and checks when client sends data to process .
        -:  267: Any client that is disconnected will be handled
        -:  268: the message sent by one client is broadcasted to all other active cllients*/
    #####:  269:void Server :: serv_select()
        -:  270:{
    #####:  271:	for(int i=0;i<max_clients;i++)
        -:  272:	{
    #####:  273:		client_sockets[i] = 0;	
        -:  274:	}
    #####:  275:	serverfd =getServSockfd();
    #####:  276:	FD_ZERO(&master);
        -:  277:	while(true)
        -:  278:	{	
        -:  279:		//create fd_set	
    #####:  280:		Create_fdset();
        -:  281:		// for adding new client socket to set
    #####:  282:		Add_ClientSocketfd();
    #####:  283:		int SelectSocket = select(max_socket+1,&readfds,NULL,NULL,NULL);
        -:  284:		//Registration and login
    #####:  285:		registeruser_login();
    #####:  286:		for(int i=0;i<max_clients;i++)
        -:  287:		{
    #####:  288:			SocketFD = client_sockets[i];
    #####:  289:			if(FD_ISSET (SocketFD, &readfds))
        -:  290:			{
    #####:  291:				memset(buff,0,MAX_BUF);
    #####:  292:				if((readVal = read(SocketFD, buff,MAX_BUF)) == 0)
        -:  293:				{
    #####:  294:					handle_disconnect();	
        -:  295:			
        -:  296:				}
        -:  297:				else
        -:  298:				{
        -:  299:				//broadcast message	
    #####:  300:					broadcast_msg();	
    #####:  301:					memset(buff,0,MAX_BUF);
        -:  302:				}
        -:  303:
        -:  304:			}
        -:  305:		}
        -:  306:
    #####:  307:	}// end of while loop
        -:  308:	Server_Close(getServSockfd());
        -:  309:}
        -:  310:/*this function creates a logfile which stores all the log messages at runtime
        -:  311: along with the time stamp*/
    #####:  312:void Server::log(string logs)
        -:  313:{
        -:  314:	FILE *logfile;
    #####:  315:	char filename[100]="logs/Serverdata.log";
    #####:  316:	time_t ltime=time(NULL);
        -:  317:	struct tm res;
        -:  318:	char TIMESTAMP[32];
    #####:  319:	char* msg = const_cast<char*>(logs.c_str());
    #####:  320:	localtime_r(&ltime,&res);
    #####:  321:	asctime_r(&res,TIMESTAMP);
    #####:  322:	logfile=fopen(filename,"a+");
    #####:  323:	fprintf(logfile,"\n~~%s\t%s\n-------------\n",TIMESTAMP,msg);
    #####:  324:	fclose(logfile);
        -:  325:
    #####:  326:}
